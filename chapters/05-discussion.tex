\chapter{Discussion}
\label{ch:discussion}

The aim of the project was to design and build a prototype of a High-Altitude
Balloon modular platform, similar in principle to buses used in the satellite
industry, and evaluate both the feasibility of such a platform and its
performance. The platform was required to allow for stable internal
communications between the payloads and the \acrlong{obc}, tracking of
ancillary data (\acrshort{gnss} co-ordinates and altitude) and reliable
transmission of the collected telemetry to one or multiple ground stations 
through a low-power radio channel. In this chapter, the \acrshort{ahabus}
platform prototype is evaluated against these aims, first by analysing the
results of tests discussed in chapter \ref{ch:results}, then through more
general qualitative observation and analysis. This chapter finally presents the
further work that would be required for the platform to fully meet its design
goals, leading to potential test flights.

\section{Project Evaluation}

Overall, the project could be considered a success. As further section discuss,
some issues were encountered, and most aspects of the \acrshort{ahabus}
platform, protocols and toolchain still require refinement and further testing,
but the results and observation presented in chapter \ref{ch:results} showed
that developing a modular platform for \acrlong{hab} missions based on the
concept of satellite buses is feasible.

\subsection{Platform}

As a software platform, the \acrshort{ahabus} prototype fulfils most of its
goals: the flight \acrshort{fcore} was complete enough to support full-flight
simulations, manage the bus, \acrshort{gnss} and radio communications without
failure. During the testing phase, no major software design error were found,
and the only instances where failures were found to be caused by the flight
software itself. Though quite cumbersome to work with, and lacking in
documentation, the \acrshort{fcore} configuration tool discussed in section
\ref{sssec:conf-file} proved reliable, and the resulting \acrshort{fcore} builds
did not suffer from erroneous bandwidth usage.

There are, however, areas that could be improved upon: the software design of
\acrshort{fcore} makes use of numerous data buffers for the different
transmission layers. Those buffers are required because of the slow speeds that
those communications protocol use, but are at the moment not optimised to be as
small as required â€“ instead, all buffers can hold \SI{4096}{\byte}. This would
prevent the current source code to be ported to architectures that provide less
dynamic memory than the chosen ESP8266 micro-controller does.

While the platform proved reliable and would be well suited for scientific
missions, where most of the generated telemetry is numerical measurements, it
might be less adequate for student missions where most users would expect to
transmit more data, like real-time pictures: the packets size limit
(\SI{420}{\byte}) would make transmitting any reasonably-sized image impossible.
This issue could potentially be solved by adding time division algorithms other
than the one presented in section \ref{ssec:conf-file}.

Due to lack of time, very little work was done on the hardware aspect of
\acrshort{ahabus}: testing was done using a development board instead of the
bare micro-controller for the \acrlong{obc}, and the power and payload bus were
little more than wires routed through a breadboard. An improved development
platform using a printed circuit board was designed as presented in
\ref{sec:flight-hardware}, but could not be fully assembled and tested in time.

\subsection{Radio Communications System}

The radio protocol and its software implementation proved equally time consuming
and successful. For reasons explained in this section, the protocol could not
be considered final or perfect, but the version developed over the duration of
the project proved reliable enough to transmit large amounts of data over long
simulated test missions.

There were however some observed issues, both in the design of the protocol and
in the frame and packet decoder implementation. First, the current use of a
16-bit unsigned integer to encode the platform's altitude in packet's header
could be problematic even though it did not cause problems during testing: first
because some locations on Earth are located below the mean sea level, leading to
negative altitudes that cannot be encoded with unsigned integers. Then because
the use of 16 bits, while sufficient to encode the altitudes at which balloons
normally fly, leave little to no margin for expansion, for example to
\acrshort{hab}-launched small rockets, or eventually nano-satellites.

Furthermore, it was observed that the reliance on frame length to detect the
end of a frame is error-prone. The current implementation of the frame decoder
counts the 256 bytes that follow a frame start marker as the frame,
unconditionally. As described in section \ref{ssec:results-rtx}, this causes
an issue where dropped bytes in the middle of the frame will cause the start
of the following frame to be consumed as the end of the current one.

One solution to this issue would be the use of an end-of-frame marker instead,
and to reject frames that are shorter than 256 bytes. However, this approach
would be challenging to implement in the context of the \acrshort{ahabus} radio
protocol. Because the end marker value might occur in the frame's content, it
must be escaped so that the decoder does not interpret a content byte as the
frame end. This can be achieved through \textit{byte stuffing}: an escape value
is chosen, and any end marker or escape value that occurs in the content must
be preceded by the escape value. The use of \acrshort{fec} in the protocol
further complicates the issue: the \acrlong{ecc} would have to be escaped too,
making frames impossible to error-correct before the escaped bytes have been
resolved by the decoder. This means that a single corrupted escape byte in a
received frame would prevent the frame from being corrected at all, even if the
number of invalid bytes is inferior to the \acrshort{fec} algorithm limit.

\subsection{Payload Bus}



\subsection{Ground Segment}

The ground segment software was found to be reliable and sufficient for the
initial round of testing. All requirements were met: the modified version of
Dl-Fldigi was stable during the tests and successfully broadcasted the decoded
raw binary stream. The packet decoder/parser was sufficient to gather
information about the radio communication statistics and the platform's health
during missions, and received payload data was successfully written to disk
and marked as either valid or invalid.

While the current toolchain was sufficient for testing, and would likely be
usable for further tests, better packet forwarding would be required for a
finished software suite. While the current solution writes data directly to the
local drive of the receiving computer, a better solution might be to forward
decoded data and metadata for each packet to a socket on the local network, or
a server, so that client applications can be built for each team. This would
allow customised dashboards more apt to decode payload-specific data, and the
parser would only act as a dispatcher, and possibly a way to monitor the
\acrshort{ahabus} platform itself during its flight.

\section{Analysis of Test Results}

This section aims to explain and analyse the quantitative results obtained
during the testing phase of the project. The results are presented in chapter
\ref{ch:results}, and the raw data files obtained from each tests are included
in appendices \ref{} through \ref{}, or on the project's GitHub account at
https://github.com/ahabus/results

\subsection{Day-in-the-Life Test}

\subsection{Radio System Resilience Tests}

\section{Further Work} % << mix in with the rest?